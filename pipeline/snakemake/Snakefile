from __future__ import annotations

import csv
from pathlib import Path

# Run configuration validation as the first step
import subprocess
import sys

try:
    # Use the new validation script
    subprocess.run(["python", "scripts/validate_config.py"], check=True)
except (subprocess.CalledProcessError, FileNotFoundError):
    sys.exit(1) # Exit if validation fails or script not found

from utils.functions import (
    ensure_directory,
    read_contrasts,
    read_samples,
    sample_is_single_end,
)
import yaml

# from utils.schema import validate_config # No longer needed

# Import caching system
try:
    from cache_manager import get_cache_manager, should_skip_stage, mark_stage_complete
    CACHE_ENABLED = config.get("cache", {}).get("enabled", True)
    CACHE_DIR = config.get("cache", {}).get("dir", ".cache")
    cache_manager = get_cache_manager(CACHE_DIR, CACHE_ENABLED)
except ImportError:
    # Fallback if cache_manager not available
    CACHE_ENABLED = False
    cache_manager = None

configfile: "config/params.yaml"

# Load genome configurations
with open("config/genome.yaml") as f:
    genome_config = yaml.safe_load(f)

# Select the active organism's paths
organism = config["organism_name"]
if organism not in genome_config:
    raise ValueError(f"Organism '{organism}' not found in config/genome.yaml")
REFERENCE_CONFIG = genome_config[organism]

# --- Dynamic Resource Allocation ---

def get_resource_profile_for_sample(wildcards, rule_name: str) -> str:
    """
    Calls the estimation script to get the profile (small, medium, large) for a sample.
    """
    # For rules that run per sample, we can determine the profile from the FASTQ size
    if hasattr(wildcards, "sample"):
        # We need to find the FASTQ file for this sample. Use R1.
        fastq_path = FASTQ_LOOKUP[wildcards.sample]["R1"]
        
        # Use a shell command to run our script and capture the output
        try:
            profile = subprocess.check_output(
                ["python", "scripts/estimate_resources.py", fastq_path],
                text=True
            ).strip()
            return profile
        except (subprocess.CalledProcessError, FileNotFoundError):
            # Fallback to a default if the script fails or file doesn't exist (e.g., dry run)
            return "small"
    
    # For rules that don't operate on a single sample (like deseq2), we might use a default or average
    return "medium"

def get_resources(wildcards, rule_name: str, resource_type: str):
    """
    Looks up the requested resource (threads or mem_gb) for a given rule and profile.
    """
    profile = get_resource_profile_for_sample(wildcards, rule_name)
    
    # Get the resource value from the config, falling back to the default
    default_resources = config["resource_profiles"]["default"]
    value = config["resource_profiles"].get(rule_name, {}).get(profile, {}).get(resource_type)
    
    if value:
        return value
    else:
        # Fallback to default if the specific profile/rule is not defined
        return default_resources[resource_type]


# validate_config(config) # No longer needed, handled by script call above

PROJECT_DIR = Path.cwd()
LOG_DIR = Path(config["paths"]["logs"])
ensure_directory(LOG_DIR)

samples = read_samples(config["paths"]["samples"])
SAMPLES = [row["sample"] for row in samples]
SAMPLE_LOOKUP = {row["sample"]: row for row in samples}

FASTQ_LOOKUP = {}
for sample in SAMPLES:
    row = SAMPLE_LOOKUP[sample]
    fastqs = {"R1": row.get("fastq_1")}
    if row.get("fastq_2"):
        fastqs["R2"] = row.get("fastq_2")
    FASTQ_LOOKUP[sample] = fastqs


contrasts = read_contrasts(config["r"]["contrasts_file"])
CONTRAST_LABELS = [f"{a}_vs_{b}" for a, b in contrasts]

# Allow overriding the results directory from the command line, e.g., for smoke tests
RESULTS_DIR = Path(config.get("results_dir", config["paths"]["outdir"]))

QC_DIR = RESULTS_DIR / "qc"
SALMON_DIR = RESULTS_DIR / "salmon"
COUNTS_DIR = RESULTS_DIR / "counts"
DE_DIR = RESULTS_DIR / "de"
FGSEA_DIR = RESULTS_DIR / "fgsea"
SALMON_INDEX_DIR = Path(REFERENCE_CONFIG["salmon_index"])
TX2GENE = SALMON_INDEX_DIR / "tx2gene.tsv"
DE_TABLE_PATHS = [DE_DIR / f"DE_{label}.tsv" for label in CONTRAST_LABELS]
FGSEA_TABLE_PATHS = [FGSEA_DIR / f"fgsea_{label}.tsv" for label in CONTRAST_LABELS]
DE_FIG_DIR = DE_DIR / "figures"
FGSEA_FIG_DIR = FGSEA_DIR / "figures"
REPORT_HTML = RESULTS_DIR / "report.html"

for path in [RESULTS_DIR, QC_DIR, SALMON_DIR, COUNTS_DIR, DE_DIR, FGSEA_DIR, LOG_DIR]:
    ensure_directory(path)

QC_FASTQC_DIR = QC_DIR / "fastqc"
QC_MULTIQC_DIR = QC_DIR / "multiqc"
ensure_directory(QC_FASTQC_DIR)
ensure_directory(QC_MULTIQC_DIR)

ensure_directory(DE_FIG_DIR)
ensure_directory(FGSEA_FIG_DIR)

ensure_directory(LOG_DIR / "slurm")

SEQUENCING_MODE = "single" if sample_is_single_end(config) else "paired"

include: "rules/qc.smk"
include: "rules/salmon.smk"
include: "rules/tximport_de.smk"
include: "rules/singlecell.smk"
include: "rules/report.smk"

rule all:
    input:
        REPORT_HTML,
        expand(QC_DIR / "fastqc" / "{sample}_{read}_fastqc.zip", sample=SAMPLES, read=["R1", "R2"] if SEQUENCING_MODE == "paired" else ["R1"]),
        QC_DIR / "multiqc" / "multiqc_report.html",
        expand(SALMON_DIR / "{sample}" / "quant.sf", sample=SAMPLES),
        COUNTS_DIR / "counts.tsv",
        COUNTS_DIR / "tpm.tsv",
        DE_DIR / "de_summary.tsv",
        expand(DE_DIR / "DE_{label}.tsv", label=CONTRAST_LABELS),
        FGSEA_DIR / "fgsea_summary.tsv",
        # Conditionally include single-cell output
        SINGLECELL_OUTPUT_DIR / ".singlecell_complete" if config.get("singlecell", {}).get("enabled", False) else []
